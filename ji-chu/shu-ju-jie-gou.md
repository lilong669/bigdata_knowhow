# 数据结构

### 数组

* 连续，顺序，将数据码成一排进行存放。
* 连续的，支持根据`index`快速检索数据（随机访问），但是对于任意位置添加或任意位置删除时间复杂度存在最好和最坏的情况。

### 链表

* 非连续的，非顺序
* 通过指针链接每个元素
* 单链表和双链表

### 栈

* 线性结构
* 后进先出的数据结构，Last In First Out(LIFO)

### 队列

* &#x20;基于数组实现的线性结构
* 是一种FIFO(先进先出)的数据结构，First In First Out(FIFO)



数组实现的栈在随机访问方面更快,但扩展性较差。

链表实现的栈在动态扩展方面更灵活,但访问效率相对较低。

### 二叉树

* 二叉树具有天然的递归结构
  * 每个节点的左子树也是二叉树
  * 每个节点的右子树也是二叉树
* 二分搜索数时二叉树
  * 二分搜索数的每个节点的值都大于其左子树所有节点的值，小于其右子树的所有节点的值。
  * 每颗子树也是一个二分搜索树

### 堆

* 二叉堆是一颗满二叉树
* 堆中某节点的值总是不大于其父节点的值，最大堆
* 父亲节点index是`(childIndex-1)/2`,`LeftChildIndex=parentIndex * 2+1`,`RightChildIndex=parentIndex * 2+2`

### AVL树 平衡二叉树

* 对于任意一个节点，左子树和右子树的高度差不能为超过1。
* 标注节点的高度，计算平衡因子，平衡因子为高度差，一旦其绝对值大于等于2则不为平衡二叉树。

### 哈希表

* 整型
  * 小范围正整数直接使用
  * 小范围负整数进行偏移

**原则**

* 一致性:如果a==b,hash(a)==hash(b)
* 高效性:计算高效简便
* 均匀性:哈希值均匀分布

### BITMAP

使用Bitmap来统计会员ID的总量是一个非常高效的解决方案。以下是具体的实现步骤:

1. 初始化Bitmap:
   * 首先需要确定会员ID的取值范围,假设范围为 \[0, 1000000)。
   * 创建一个长度为 1,000,000 的Bitmap数组,初始化全部为0。
2. 记录会员ID:
   * 遍历所有会员ID,对于每个ID,将对应的Bitmap位置设置为1。
3.  统计总量:

    * 遍历Bitmap数组,统计值为1的位数即可得到总的会员数量。



高效地实现集合的交、并、补

可以作为索引结构使用,极大地提高查询速度

缓存或过滤器,判断元素是否存在于集合中

有0和1两种状态的数据,Bitmap可以提供非常高的压缩率

ROARING BIMAP

* 区间内数据较多，且分布零散，则选择（未压缩）位图
* 区间内数据较少，且分布零散，则选择使用有序数组
* 区间内数据连续分布，则选择用Run Length Encoding编码

Roaring将Bitmap从一层的连续存储，转换为一个二级的存储结构

* 第一层称之为Chunk，每个Chunk表示该区间取值范围的base(n2^16, 0<= n < 2^16)，如果该取值范围内没有数据则Chunk不会创建
* 第二层称之为Container，会依据数据分布进行创建（Container内的值实际是区间内的offset）
  * Roaring并不是一种静态数据结构，随着数据的增删，Container选择的存储格式也会随之自动调整

Roaring 提供O(logn)的查找性能：

* 首先二分查找key值的高16位是否在分片`(chunk）`中
*   如果分片存在，则查找分片对应的Container是否存在

    * 如果Bitmap Container，查找性能是O(1)
    * 其它两种Container，需要进行二分查找



Roaring使用了SIMD对操作进行了加速，但是SIMD是一门相当trick的技术，有机会可以单独再分析SIMD对性能的影响（尤其是introset／union）。

INT 数组 / BITMAP / ROARING BITMAP这三者的性能对比

1. 对于数据量较小的情况,int 数组的遍历性能可能略优于 Bitmap 和 Roaring Bitmap。
2. 当数据量较大时,Bitmap 和 Roaring Bitmap 的内存利用率更高,遍历效率会更好。
3. 在处理超大规模数据时,Roaring Bitmap 由于采用了更优秀的压缩算法和并行技术,遍历性能会明显优于普通的 Bitmap。
