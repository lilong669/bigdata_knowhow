# 数据结构

数组

* 连续，顺序，将数据码成一排进行存放。
* 连续的，支持根据`index`快速检索数据（随机访问），但是对于任意位置添加或任意位置删除时间复杂度存在最好和最坏的情况。

链表

* 非连续的，非顺序
* 通过指针链接每个元素
* 单链表和双链表

栈

* 线性结构
* 后进先出的数据结构，Last In First Out(LIFO)

队列

* &#x20;基于数组实现的线性结构
* 是一种FIFO(先进先出)的数据结构，First In First Out(FIFO)



数组实现的栈在随机访问方面更快,但扩展性较差。

链表实现的栈在动态扩展方面更灵活,但访问效率相对较低。

二叉树

* 二叉树具有天然的递归结构
  * 每个节点的左子树也是二叉树
  * 每个节点的右子树也是二叉树
* 二分搜索数时二叉树
  * 二分搜索数的每个节点的值都大于其左子树所有节点的值，小于其右子树的所有节点的值。
  * 每颗子树也是一个二分搜索树

堆

* 二叉堆是一颗满二叉树
* 堆中某节点的值总是不大于其父节点的值，最大堆
* 父亲节点index是`(childIndex-1)/2`,`LeftChildIndex=parentIndex * 2+1`,`RightChildIndex=parentIndex * 2+2`

AVL树 平衡二叉树

* 对于任意一个节点，左子树和右子树的高度差不能为超过1。
* 标注节点的高度，计算平衡因子，平衡因子为高度差，一旦其绝对值大于等于2则不为平衡二叉树。

哈希表

* 整型
  * 小范围正整数直接使用
  * 小范围负整数进行偏移

**原则**

* 一致性:如果a==b,hash(a)==hash(b)
* 高效性:计算高效简便
* 均匀性:哈希值均匀分布

BITMAP

使用Bitmap来统计会员ID的总量是一个非常高效的解决方案。以下是具体的实现步骤:

1. 初始化Bitmap:
   * 首先需要确定会员ID的取值范围,假设范围为 \[0, 1000000)。
   * 创建一个长度为 1,000,000 的Bitmap数组,初始化全部为0。
2. 记录会员ID:
   * 遍历所有会员ID,对于每个ID,将对应的Bitmap位置设置为1。
3.  统计总量:

    * 遍历Bitmap数组,统计值为1的位数即可得到总的会员数量。



高效地实现集合的交、并、补

可以作为索引结构使用,极大地提高查询速度

缓存或过滤器,判断元素是否存在于集合中

有0和1两种状态的数据,Bitmap可以提供非常高的压缩率



