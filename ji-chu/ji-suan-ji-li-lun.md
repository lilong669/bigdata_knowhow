# 计算机理论

## B+树和LSM树的优缺点

B+索引树和log型（append）文件操作（数据库WAL日志）是数据读写的两个极端。

B+树读效率高而写效率差；

log型文件操作写效率高而读效率差；

因此要在排序和log型文件操作之间做个折中，于是就引入了**log-structed merge tree**模型，通过名称可以看出LSM既有日志型的文件操作，提升写效率，又在每个`sstable`中排序，保证了查询效率。

## LSM存储模型

查找primary-key的过程很高效，但是调整B+树的磁盘IO开销却很大，因此关系型数据库mysql的写效率一直饱受诟病。**那有没有一种替代B+树的数据组织模型，在不太影响读效率的前提下，提高数据的写效率（随机写->顺序写）**

### Hash索引



1. 常数时间的查找性能:
   * 哈希索引使用哈希函数将键值映射到一个特定的位置(槽位)上,查找时只需要通过哈希函数就可以直接定位到该位置,时间复杂度为 O(1)。这比 B+ 树的 O(log n) 查找效率更高。
2. 高效的更新和删除:
   * 由于哈希索引的查找和定位都是基于哈希函数,所以更新和删除操作也能在常数时间内完成,不需要像 B+ 树那样进行复杂的结构调整。
3. 节省空间:
   * 哈希索引不需要保存键值的顺序信息,因此在存储结构上更加紧凑,比 B+ 树索引节省更多的存储空间

* 常数时间的查找性能:
  * 哈希索引使用哈希函数将键值映射到一个特定的位置(槽位)上,查找时只需要通过哈希函数就可以直接定位到该位置,时间复杂度为 O(1)。这比 B+ 树的 O(log n) 查找效率更高。
* 高效的更新和删除:
  * 由于哈希索引的查找和定位都是基于哈希函数,所以更新和删除操作也能在常数时间内完成,不需要像 B+ 树那样进行复杂的结构调整。

### LSM如何解决问题Log-Structured Merge-Tree

LSM树(Log-Structured Merge-Tree)是一种针对磁盘存储的数据结构,它与传统的B+树相比有以下几个优点:

1. 更高的写入性能:
   * LSM树通过将更新操作先写入内存缓存(MemTable),然后定期将MemTable中的数据批量刷新到磁盘,减少了单个磁盘写入的开销。这种方式能大幅提高写入性能。
2. 更好的空间利用效率:
   * LSM树将数据存储在多个不同级别的文件中,较新的数据存储在更高级别的文件中。当某个文件中的数据太多时,会将其与下一级别的文件合并,从而减少了磁盘空间的浪费。
3. 更高的读取性能:
   * 对于读取操作,LSM树会先检查内存中的MemTable,如果未找到则查找磁盘上的文件。为了加快读取,LSM树会构建布隆过滤器(Bloom Filter)等数据结构来加速查找。
4. 更好的数据压缩:
   * LSM树的数据分散在多个文件中,这使得可以对每个文件单独进行压缩,从而获得更高的压缩比。

不过,LSM树也有一些缺点:

1. 需要复杂的后台管理:
   * LSM树需要定期进行文件合并和压缩等操作,这增加了系统复杂度和维护成本。
2. 更高的写放大:
   * 由于要将数据从内存刷新到磁盘,再进行合并操作,LSM树会产生较高的写放大(Write Amplification)。
3. LSM-Tree大量写优于B-Tree的原因
   1. **multi-page block**：不同于B-Tree，LSM-Tree的延时写(数据可以积攒)可以有效的利用multi-page block，在Rolling Merge的过程中，一次从C1中读出多个连续pages，与C0进行Merge，然后一次向C1写回这些连续pages，这样有效利用单次I/O完成多个pages的读写（B-Tree在此场景下无法利用multi-page的优势）
   2. **batch**：同样因为延迟写，LSM-Tree可以在Rolling Merge中，通过一次I/O批量向C1写入C0多条数据，那么这多条数据就均摊了这一次I/O，减少磁盘的I/O开销
